<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
<style>
path { 
    stroke-width: 2;
    fill: none;
    stroke-linejoin: round;
    stroke-linecap: round;
}
circle { 
  stroke-width: 3;
}
.axis path,
.axis line {
  fill: none;
  stroke: grey;
  stroke-width: 4;
  shape-rendering: crispEdges;
}
.legend, .label, .hover-text{
    font-size: 20px;
    background-color: white;
}

svg {
  top: 300px;
}

h1, h2, h3, h4, h5, h6 {
  float: left;
  width: 100%;
}

ul {
  width: 100%;
}

li {
    display: block;
    float: left;
    font-size: 23px;
    margin-right: 20px;
}

div {
  font-size: 20px;
	float: none;
}

.list {
	width: 100%;
  float: left;
}

.graphs {
  float: center;
	margin-top: 10px;
}

body {
  float: left;
}

p {
  font-weight: bold;
	font-size: 23px;
}

a {
  color: inherit;
}
.type {
	color: blue;
	font-weight: bold;
	font-size: 60px;
}
.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}
</style>
<script>
function hideIt(d) {
    var l = document.getElementsByClassName(d.textContent);
    for (var i = 0; i < l.length; i++) {
      if(l[i].style.display=='none'){
        l[i].style.display='block';
        d.style.color='blue';
      } else {
        l[i].style.display='none';
        d.style.color='grey';
      }
    }

}

function checkbox_clicked(checkboxElem) {
  if (checkboxElem.checked) {
    document.getElementById(checkboxElem.parentNode.attributes["name"].nodeValue).style.display='none';
    checkboxElem.parentNode.style.color='grey';    
  } else {
    document.getElementById(checkboxElem.parentNode.attributes["name"].nodeValue).style.display='block';
    checkboxElem.parentNode.style.color='black';    
  }
}
</script>
<div>
<h1><center> Tools </center></h1>
<p id="p1"> zearch:</p>
<p id="p2"> grep:</p>
<p id="p3"> ripgrep:</p>
<p id="p4"> hyperscan:</p>
<p id="p5"> lz4|hyperscan:</p>
<p id="p6"> zstd|hyperscan:</p>
<p id="p7"> lz4|grep:</p>
<p id="p8"> zstd|grep:</p>
<p id="p9"> lz4|ripgrep:</p>
<p id="p10"> zstd|ripgrep:</p>
<p id="p11"> repair:</p>
<p id="p12"> lz4:</p>
<p id="p13"> zstd:</p>
<p id="p14"> gzip:</p>
<br>
<h1><center> Overview </center></h1>
<div class="description">
The running time shown for each regular expression is the <a href="https://en.wikipedia.org/wiki/Confidence_interval">confidence interval</a> computed over 30 runs, measured after a "warming up" run. When the confidence intervals of two experiments do not overlap then we have enough statistical evidence to claim that one tool outperforms the other on the given experiment.
If an execution takes more than 10 times the time required by zearch it is considered a timeout.
</div>
<br>
<hr>
<center><h1 class="type" onclick="hideIt(this)">Subtitles</h1></center>
<div class="list Subtitles">
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "but where are you",</li>
<li>r4: "have",</li>
<li>r5: "I love you",</li>
<li>r6: "a",</li>
<li>r7: "\.",</li>
<li>r8: "I .* you",</li>
<li>r9: "[a-z]{4}",</li>
<li>r10: "[0-9]{9}",</li>
<li>r11: " (19|20)[0-9]{2} ",</li>
<li>r12: " [a-z]{2} ",</li>
<li>r13: " [0-9]5[0-9]0[0-9]4[0-9]5[0-9] ",</li>
</ul>
</div>
<script>
	var colors20 = d3.scale.category20();
	var color = d3.scale.ordinal()
		.domain(["zearch","grep","ripgrep","hyperscan","zhs_lz4_p","zhs_zstd_p","zgrep_lz4_p","zgrep_zstd_p","zrg_lz4_p","zrg_zstd_p","repair","lz4", "zstd","gzip"])
		.range(["#4363d8","#ffd000","#800000","#808000","#e6194B","#fabebe","#f032e6","#e6beff","#3cb44b","#aaffc3","#4363d8","#f032e6","#42d4f4","#800000"]);
document.getElementById("p1").style.color = color("zearch");
document.getElementById("p2").style.color = color("grep");
document.getElementById("p3").style.color = color("ripgrep");
document.getElementById("p4").style.color = color("hyperscan");
document.getElementById("p5").style.color = color("zhs_lz4_p");
document.getElementById("p6").style.color = color("zhs_zstd_p");
document.getElementById("p7").style.color = color("zgrep_lz4_p");
document.getElementById("p8").style.color = color("zgrep_zstd_p");
document.getElementById("p9").style.color = color("zrg_lz4_p");
document.getElementById("p10").style.color = color("zrg_zstd_p");
document.getElementById("p11").style.color = color("repair");
document.getElementById("p12").style.color = color("lz4");
document.getElementById("p13").style.color = color("zstd");
document.getElementById("p14").style.color = color("gzip");
</script>
<div class="graphs Subtitles">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale

</script>
<svg id="svg1MBSubtitles" width="1800" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

});
})();
</script>
<svg id="svg1MBSubtitles_cactus" width="1400" height="800"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info1MBSubtitles_cactus
var info1MBSubtitles_cactus = svg.selectAll(".info1MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (350 + i * 25) + ")"; });

  info1MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line1MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line1MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info1MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
