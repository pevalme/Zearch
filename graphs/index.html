<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
<style>
path {
    stroke-width: 2;
    fill: none;
    stroke-linejoin: round;
    stroke-linecap: round;
}
circle {
  stroke-width: 3;
}
.axis path,
.axis line {
  fill: none;
  stroke: grey;
  stroke-width: 4;
  shape-rendering: crispEdges;
}
.legend, .label, .hover-text{
    font-size: 20px;
    background-color: white;
}

svg {
  float: left;
  top: 300px;
}

h1, h2, h3, h4, h5, h6 {
  float: left;
  width: 100%;
}
.boxplot {
  float: left;
  top: 300px;
  width: 900px;
  height: 600px;
  margin: auto;
}

ul {
  width: 100%;
}

li {
    display: block;
    float: left;
    font-size: 23px;
    margin-right: 20px;
}

div {
  font-size: 20px;
	float: none;
}

.description {
  width: 80%;
  margin: auto;
}

.list {
	width: 100%;
  float: left;
}

.graphs {
  float: left;
	margin-top: 10px;
}

body {
  float: left;
}

p {
  font-weight: bold;
	font-size: 23px;
}

a {
  color: inherit;
}
.type {
	color: blue;
	font-weight: bold;
	font-size: 60px;
}
.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}
</style>
<script>
function hideIt(d) {
    var l = document.getElementsByClassName(d.textContent);
    for (var i = 0; i < l.length; i++) {
      if(l[i].style.display=='none'){
        l[i].style.display='block';
        d.style.color='blue';
      } else {
        l[i].style.display='none';
        d.style.color='grey';
      }
    }

}

function checkbox_clicked(checkboxElem) {
  if (checkboxElem.checked) {
    document.getElementById(checkboxElem.parentNode.attributes["name"].nodeValue).style.display='none';
    checkboxElem.parentNode.style.color='grey';
  } else {
    document.getElementById(checkboxElem.parentNode.attributes["name"].nodeValue).style.display='block';
    checkboxElem.parentNode.style.color='black';
  }
}
</script>
<div>
<h1><center> Tools </center></h1>
<p id="p1"> <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>: Run with maximum dfa-size-limit and regex-size-limit. Version: 0.7.1</p>
<p id="p2"> <a href="https://ftp.gnu.org/gnu/grep/">grep</a>: Version: 3.1</p>
<p id="p3"> <a href="https://github.com/pevalme/zearch">zearch</a>: Using the algorithms described <a href="https://pevalme.github.io/zearch/main.pdf">here</a></p>
<p id="p4"> zgrep: Search with grep on the uncompressed text as it is recovered with zstd. Uses two processes.</p>
<p id="p5"> zrg: Search with ripgrep on the uncompressed text as it is recovered with zstd. Uses two processes.</p>
<p id="p6"> <a href="http://manpages.ubuntu.com/manpages/trusty/man1/gzip.1.html">gzip</a>: Output sent to dev/null. Arguments used as in zgrep (-cdfq). Version: 1.6</p>
<p id="p7"> <a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/re-pair/repair110811.tar.gz">repair</a>: Output sent to dev/null. Version: 110811</p>
<p id="p8"> <a href="https://github.com/facebook/zstd">zstd</a>: Output sent to dev/null. Version: 1.3.2</p>
</div>
<br>
<h1><center> Overview </center></h1>
<div class="description">
The running time shown for each regular expression is the <a href="https://en.wikipedia.org/wiki/Confidence_interval">confidence interval</a> computed over 30 runs, measured after a "warming up" run. When the confidence intervals of two experiments do not overlap then we have enough statistical evidence to claim that one tool outperforms the other on the given experiment.
If an execution takes more than 10 times the time required by zearch it is considered a timeout.
</div>
<br>
<hr>
<center><h1 class="type" onclick="hideIt(this)">Subtitles</h1></center>
<div class="list Subtitles">
<h2><center> File </center></h2>
<div class="description">
File containing English subtitles extracted from the <a href="http://opus.nlpl.eu/OpenSubtitles2016.php">OpenSubtitles2016</a> dataset. As a reference, the 100 MB long file is compressed by repair, zstd and gzip to 12 MB, 14 MB and 31 MB, respectively.
</div>
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "but where are you",</li>
<li>r4: "have",</li>
<li>r5: "I love you",</li>
<li>r6: "a",</li>
<li>r7: "\.",</li>
<li>r8: "I .* you",</li>
<li>r9: "[a-z]{4}",</li>
<li>r10: "[0-9]{9}",</li>
<li>r11: " (19|20)[0-9]{2} ",</li>
<li>r12: "[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}",</li>
<li>r13: " [a-z]{2} ",</li>
<li>r14: "[a-z]{5} +[a-z]{5} +[a-z]{5} +[a-z]{5} +[a-z]{5} +[a-z]{5} +[a-z]{5}",</li>
<li>r15: " [a-z]*[a-z]{30} ",</li>
<li>r16: " [0-9]5[0-9]0[0-9]4[0-9]5[0-9] ",</li>
</ul>
</div>
<script>
  var color = d3.scale.category10();
  document.getElementById("p1").style.color = color(1);
  document.getElementById("p2").style.color = color(2);
  document.getElementById("p3").style.color = color(3);
  document.getElementById("p4").style.color = color(4);
  document.getElementById("p5").style.color = color(5);
  document.getElementById("p6").style.color = color(6);
  document.getElementById("p7").style.color = color(7);
  document.getElementById("p8").style.color = color(8);
</script>
<div class="graphs Subtitles">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale
var color = d3.scale.category10();

</script>
<svg id="svg100KBSubtitles" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBSubtitles"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBSubtitles.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100KBSubtitles_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBSubtitles_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBSubtitles_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100KBSubtitles_cactus
var info100KBSubtitles_cactus = svg.selectAll(".info100KBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100KBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBSubtitles_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBSubtitles_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100KBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBSubtitles" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBSubtitles"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBSubtitles.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg25MBSubtitles_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBSubtitles_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBSubtitles_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info25MBSubtitles_cactus
var info25MBSubtitles_cactus = svg.selectAll(".info25MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info25MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBSubtitles_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info25MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBSubtitles" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBSubtitles"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBSubtitles.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100MBSubtitles_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBSubtitles_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBSubtitles_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100MBSubtitles_cactus
var info100MBSubtitles_cactus = svg.selectAll(".info100MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBSubtitles_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">JSON</h1></center>
<div class="list JSON">
<h2><center> File </center></h2>
<div class="description">
A sample of the public timeline recorded by <a href="https://www.githubarchive.org/">GitHub Archive</a> in JSON format, where each line of the file corresponds with a JSON element describing an activity. As a reference, the 100 MB long file is compressed by repair, zstd and gzip to 8.8 MB, 8.9 MB and 14 MB, respectively.
</div>
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: ""message":"Update ",</li>
<li>r4: "master",</li>
<li>r5: "Pedro",</li>
<li>r6: ""[a-z]{10}":",</li>
<li>r7: ""created_at":"2017-10-17T(1[5-9]|2[0-4]):[0-9]{2}:[0-9]{2}Z"",</li>
<li>r8: ""created_at":"2017-10-17T(1[0-9]|2[0-4]):[0-9]{2}:[0-9]{2}Z"",</li>
<li>r9: "[0-9]5[0-9]0[0-9]4[0-9]5[0-9]",</li>
<li>r10: "\-{0,1}0[1-9]\.[1-9]*",</li>
<li>r11: "\.[1-9]+",</li>
</ul>
</div>
<script>
  var color = d3.scale.category10();
  document.getElementById("p1").style.color = color(1);
  document.getElementById("p2").style.color = color(2);
  document.getElementById("p3").style.color = color(3);
  document.getElementById("p4").style.color = color(4);
  document.getElementById("p5").style.color = color(5);
  document.getElementById("p6").style.color = color(6);
  document.getElementById("p7").style.color = color(7);
  document.getElementById("p8").style.color = color(8);
</script>
<div class="graphs JSON">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale
var color = d3.scale.category10();

</script>
<svg id="svg100KBJSON" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBJSON"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB JSON')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBJSON.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100KBJSON_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBJSON_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB JSON')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBJSON_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100KBJSON_cactus
var info100KBJSON_cactus = svg.selectAll(".info100KBJSON_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBJSON_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100KBJSON_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBJSON_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBJSON_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBJSON_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBJSON_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBJSON_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBJSON_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBJSON_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBJSON_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBJSON_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBJSON_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBJSON_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBJSON_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBJSON_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBJSON_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBJSON_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100KBJSON_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBJSON" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBJSON"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB JSON')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBJSON.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg25MBJSON_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBJSON_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB JSON')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBJSON_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info25MBJSON_cactus
var info25MBJSON_cactus = svg.selectAll(".info25MBJSON_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBJSON_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info25MBJSON_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBJSON_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBJSON_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBJSON_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBJSON_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBJSON_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBJSON_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBJSON_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBJSON_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBJSON_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBJSON_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBJSON_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBJSON_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBJSON_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBJSON_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBJSON_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info25MBJSON_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBJSON" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBJSON"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB JSON')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBJSON.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100MBJSON_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBJSON_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB JSON')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBJSON_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100MBJSON_cactus
var info100MBJSON_cactus = svg.selectAll(".info100MBJSON_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBJSON_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100MBJSON_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBJSON_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBJSON_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBJSON_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBJSON_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBJSON_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBJSON_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBJSON_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBJSON_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBJSON_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBJSON_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBJSON_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBJSON_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBJSON_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBJSON_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBJSON_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100MBJSON_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">CSV</h1></center>
<div class="list CSV">
<h2><center> File </center></h2>
<div class="description">
A sample of the <a href="http://storage.googleapis.com/books/ngrams/books/datasetsv2.html">The Google Books Ngram Viewer dataset</a> considering n-grams of 5 to 20 characters long. Each line of the file corresponds with an n-gram and its statistical information. As a reference, the 100 MB long file is compressed by repair, zstd and gzip to 27 MB, 26 MB and 37 MB, respectively.
</div>
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "1993",</li>
<li>r4: "20[0-9]{2}",</li>
<li>r5: ".*5",</li>
<li>r6: "[a-z]{5}",</li>
<li>r7: " [0-9]{9} ",</li>
</ul>
</div>
<script>
  var color = d3.scale.category10();
  document.getElementById("p1").style.color = color(1);
  document.getElementById("p2").style.color = color(2);
  document.getElementById("p3").style.color = color(3);
  document.getElementById("p4").style.color = color(4);
  document.getElementById("p5").style.color = color(5);
  document.getElementById("p6").style.color = color(6);
  document.getElementById("p7").style.color = color(7);
  document.getElementById("p8").style.color = color(8);
</script>
<div class="graphs CSV">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale
var color = d3.scale.category10();

</script>
<svg id="svg100KBCSV" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBCSV"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBCSV.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100KBCSV_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBCSV_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBCSV_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100KBCSV_cactus
var info100KBCSV_cactus = svg.selectAll(".info100KBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100KBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBCSV_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBCSV_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100KBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBCSV" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBCSV"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBCSV.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg25MBCSV_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBCSV_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBCSV_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info25MBCSV_cactus
var info25MBCSV_cactus = svg.selectAll(".info25MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info25MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBCSV_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBCSV_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info25MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBCSV" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBCSV"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBCSV.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100MBCSV_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBCSV_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBCSV_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100MBCSV_cactus
var info100MBCSV_cactus = svg.selectAll(".info100MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBCSV_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBCSV_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">Logs</h1></center>
<div class="list Logs">
<h2><center> File </center></h2>
<div class="description">
A sample of two months worth of all HTTP requests to the NASA Kennedy Space Center WWW server in Florida available <a href="http://ita.ee.lbl.gov/html/contrib/NASA-HTTP.html">here</a>. Each line of the file corresponds with an HTTP request. As a reference, the 100 MB long file is compressed by repair, zstd and gzip to 6.8 MB, 7.3 MB and 11 MB, respectively.
</div>
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "port",</li>
<li>r4: "20[0-9]{2}",</li>
<li>r5: "([0-9]{3}\.){3}[0-9]",</li>
<li>r6: "[0-9]{4}",</li>
<li>r7: "([a-z]+\.)+[a-z]+ - -",</li>
<li>r8: ""GET .*" ([13-9]|2[1-9]|2-[1-9])",</li>
<li>r9: "(([0-9])|([0-2][0-9])|([3][0-1]))/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/[0-9]{4}",</li>
<li>r10: "(([0-9])|([0-2][0-9])|([3][0-1]))-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-[0-9]{4}",</li>
</ul>
</div>
<script>
  var color = d3.scale.category10();
  document.getElementById("p1").style.color = color(1);
  document.getElementById("p2").style.color = color(2);
  document.getElementById("p3").style.color = color(3);
  document.getElementById("p4").style.color = color(4);
  document.getElementById("p5").style.color = color(5);
  document.getElementById("p6").style.color = color(6);
  document.getElementById("p7").style.color = color(7);
  document.getElementById("p8").style.color = color(8);
</script>
<div class="graphs Logs">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale
var color = d3.scale.category10();

</script>
<svg id="svg100KBLogs" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBLogs"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBLogs.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100KBLogs_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBLogs_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBLogs_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100KBLogs_cactus
var info100KBLogs_cactus = svg.selectAll(".info100KBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100KBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBLogs_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBLogs_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100KBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBLogs" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBLogs"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBLogs.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg25MBLogs_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBLogs_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBLogs_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info25MBLogs_cactus
var info25MBLogs_cactus = svg.selectAll(".info25MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info25MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBLogs_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBLogs_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info25MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBLogs" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBLogs"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBLogs.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100MBLogs_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBLogs_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBLogs_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100MBLogs_cactus
var info100MBLogs_cactus = svg.selectAll(".info100MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBLogs_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBLogs_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">Random</h1></center>
<div class="list Random">
<h2><center> File </center></h2>
<div class="description">
A file containing a single, randomly generated line belonging to the language "[0,1]*2". As a reference, the 100 MB long file is compressed by repair, zstd and gzip to 18 MB, 14 MB and 16 MB, respectively.
</div>
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "0100101",</li>
<li>r4: "[0-1]{9}",</li>
<li>r5: "[0-1]{6,10}",</li>
<li>r6: "(0110101){2}",</li>
<li>r7: "[0-1]*1[0-1]{5}2",</li>
<li>r8: "[0-1]*1[0-1]{10}2",</li>
<li>r9: "[0-1]*1[0-1]{15}2",</li>
<li>r10: "[0-1]*1[0-1]{16}2",</li>
<li>r11: "[0-1]*1[0-1]{17}2",</li>
<li>r12: "[0-1]*1[0-1]{18}2",</li>
<li>r13: "[0-1]*1[0-1]{19}2",</li>
<li>r14: "[0-1]*1[0-1]{20}2",</li>
</ul>
</div>
<script>
  var color = d3.scale.category10();
  document.getElementById("p1").style.color = color(1);
  document.getElementById("p2").style.color = color(2);
  document.getElementById("p3").style.color = color(3);
  document.getElementById("p4").style.color = color(4);
  document.getElementById("p5").style.color = color(5);
  document.getElementById("p6").style.color = color(6);
  document.getElementById("p7").style.color = color(7);
  document.getElementById("p8").style.color = color(8);
</script>
<div class="graphs Random">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale
var color = d3.scale.category10();

</script>
<svg id="svg100KBRandom" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBRandom"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Random')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBRandom.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100KBRandom_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBRandom_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Random')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBRandom_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100KBRandom_cactus
var info100KBRandom_cactus = svg.selectAll(".info100KBRandom_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBRandom_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100KBRandom_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBRandom_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBRandom_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBRandom_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBRandom_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBRandom_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBRandom_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBRandom_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBRandom_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBRandom_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBRandom_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBRandom_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBRandom_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBRandom_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBRandom_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBRandom_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100KBRandom_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBRandom" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBRandom"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Random')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBRandom.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg25MBRandom_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBRandom_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Random')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBRandom_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info25MBRandom_cactus
var info25MBRandom_cactus = svg.selectAll(".info25MBRandom_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBRandom_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info25MBRandom_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBRandom_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBRandom_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBRandom_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBRandom_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBRandom_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBRandom_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBRandom_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBRandom_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBRandom_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBRandom_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBRandom_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBRandom_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBRandom_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBRandom_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBRandom_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info25MBRandom_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBRandom" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBRandom"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Random')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBRandom.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100MBRandom_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBRandom_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Random')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBRandom_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100MBRandom_cactus
var info100MBRandom_cactus = svg.selectAll(".info100MBRandom_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBRandom_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100MBRandom_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBRandom_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBRandom_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBRandom_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBRandom_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBRandom_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBRandom_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBRandom_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBRandom_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBRandom_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBRandom_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBRandom_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBRandom_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBRandom_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBRandom_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBRandom_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100MBRandom_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">RandomL</h1></center>
<div class="list RandomL">
<h2><center> File </center></h2>
<div class="description">
A file containing multiple lines or arbitrary length over the alphabet {0,1}. Each line has been randomly generated. As a reference, the 100 MB long file is compressed by repair, zstd and gzip to 36 MB, 27 MB and 30 MB, respectively.
</div>
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "0100101",</li>
<li>r4: "[0-1]{9}",</li>
<li>r5: "[0-1]{6,10}",</li>
<li>r6: "(0110101){2}",</li>
<li>r7: "[0-1]*1[0-1]{5}2",</li>
<li>r8: "[0-1]*1[0-1]{10}2",</li>
<li>r9: "[0-1]*1[0-1]{15}2",</li>
<li>r10: "[0-1]*1[0-1]{20}2",</li>
<li>r11: "[0-1]*1[0-1]{25}2",</li>
</ul>
</div>
<script>
  var color = d3.scale.category10();
  document.getElementById("p1").style.color = color(1);
  document.getElementById("p2").style.color = color(2);
  document.getElementById("p3").style.color = color(3);
  document.getElementById("p4").style.color = color(4);
  document.getElementById("p5").style.color = color(5);
  document.getElementById("p6").style.color = color(6);
  document.getElementById("p7").style.color = color(7);
  document.getElementById("p8").style.color = color(8);
</script>
<div class="graphs RandomL">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale
var color = d3.scale.category10();

</script>
<svg id="svg100KBRandomL" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBRandomL"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB RandomL')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBRandomL.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100KBRandomL_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBRandomL_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB RandomL')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBRandomL_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100KBRandomL_cactus
var info100KBRandomL_cactus = svg.selectAll(".info100KBRandomL_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBRandomL_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100KBRandomL_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBRandomL_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBRandomL_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBRandomL_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBRandomL_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBRandomL_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBRandomL_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBRandomL_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBRandomL_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBRandomL_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBRandomL_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBRandomL_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBRandomL_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBRandomL_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBRandomL_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBRandomL_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100KBRandomL_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBRandomL" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBRandomL"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB RandomL')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBRandomL.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg25MBRandomL_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBRandomL_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB RandomL')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBRandomL_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info25MBRandomL_cactus
var info25MBRandomL_cactus = svg.selectAll(".info25MBRandomL_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBRandomL_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info25MBRandomL_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBRandomL_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBRandomL_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBRandomL_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBRandomL_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBRandomL_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBRandomL_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBRandomL_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBRandomL_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBRandomL_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBRandomL_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBRandomL_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBRandomL_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBRandomL_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBRandomL_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBRandomL_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info25MBRandomL_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBRandomL" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBRandomL"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB RandomL')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBRandomL.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100MBRandomL_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBRandomL_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB RandomL')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBRandomL_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100MBRandomL_cactus
var info100MBRandomL_cactus = svg.selectAll(".info100MBRandomL_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBRandomL_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100MBRandomL_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBRandomL_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBRandomL_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBRandomL_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBRandomL_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBRandomL_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBRandomL_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBRandomL_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBRandomL_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBRandomL_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBRandomL_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBRandomL_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBRandomL_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBRandomL_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBRandomL_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBRandomL_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100MBRandomL_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">Pedro</h1></center>
<div class="list Pedro">
<h2><center> File </center></h2>
<div class="description">
A file where each line is exactly "Pedro". As a reference, the 100 MB long file is compressed by repair, zstd and gzip to 72 B, 8.7 KB and 150 KB, respectively.
</div>
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "Pedro",</li>
<li>r3: "Pedra",</li>
<li>r4: "wosel",</li>
<li>r5: "[a-z]{5}",</li>
</ul>
</div>
<script>
  var color = d3.scale.category10();
  document.getElementById("p1").style.color = color(1);
  document.getElementById("p2").style.color = color(2);
  document.getElementById("p3").style.color = color(3);
  document.getElementById("p4").style.color = color(4);
  document.getElementById("p5").style.color = color(5);
  document.getElementById("p6").style.color = color(6);
  document.getElementById("p7").style.color = color(7);
  document.getElementById("p8").style.color = color(8);
</script>
<div class="graphs Pedro">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale
var color = d3.scale.category10();

</script>
<svg id="svg100KBPedro" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBPedro"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Pedro')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBPedro.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100KBPedro_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBPedro_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Pedro')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBPedro_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100KBPedro_cactus
var info100KBPedro_cactus = svg.selectAll(".info100KBPedro_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBPedro_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100KBPedro_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBPedro_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBPedro_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBPedro_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBPedro_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBPedro_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBPedro_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBPedro_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBPedro_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBPedro_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBPedro_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBPedro_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBPedro_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBPedro_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBPedro_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBPedro_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100KBPedro_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBPedro" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBPedro"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Pedro')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBPedro.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg25MBPedro_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBPedro_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Pedro')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBPedro_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info25MBPedro_cactus
var info25MBPedro_cactus = svg.selectAll(".info25MBPedro_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBPedro_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info25MBPedro_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBPedro_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBPedro_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBPedro_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBPedro_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBPedro_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBPedro_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBPedro_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBPedro_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBPedro_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBPedro_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBPedro_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBPedro_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBPedro_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBPedro_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBPedro_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info25MBPedro_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBPedro" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBPedro"),
  margin = { top: 100, right: 100, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Pedro')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if(d.matchesg == d.matchesr && d.matchesr == d.matchesgg) return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>(rg):</strong> <span style='color:red'>" + d.matchesr + "</span><br><strong>(grep):</strong> <span style='color:red'>" + d.matchesgg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBPedro.json", function(error, data) {
  // Select the important columns
  color.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }));
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesG,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          worth: +d[name].avg,
          err: +d[name].err
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(currencies)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "8")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "gzip") break;
  }
  var avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "repair") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= currencies.length; idx++){
    if (currencies[idx].name == "zstd") break;
  }
  avg = currencies[idx].values[currencies[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "5")
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });
});
})();
</script>
<svg id="svg100MBPedro_cactus" width="900" height="600"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBPedro_cactus"),
  margin = { top: 100, right: 200, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Pedro')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBPedro_cactus.json", function(error, data) {
  var currencies = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(currencies)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(currencies, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(currencies, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var currency = g.selectAll(".currency")
    .data(currencies)
    .enter().append("g")
    .attr("class", "currency");

  currency.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  currency.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 20 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return d; });

// Add the info100MBPedro_cactus
var info100MBPedro_cactus = svg.selectAll(".info100MBPedro_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBPedro_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (250 + i * 20) + ")"; });

  info100MBPedro_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBPedro_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBPedro_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBPedro_cactus')
  .data(currencies)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBPedro_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBPedro_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBPedro_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBPedro_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBPedro_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBPedro_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBPedro_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBPedro_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBPedro_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBPedro_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBPedro_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBPedro_cactus")[0][i].childNodes[0].innerHTML=d.name+": "+d.values[idx].worth;
        d3.selectAll(".info100MBPedro_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
